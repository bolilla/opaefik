# Fine grained Authorization in a Kubernetes ingress
## XXX Ordinary World ### (XXX remove title)

Questions are like itches asking to be scratched. Sometimes you ask yourself a question. That happens in the front of your mind; it is the conscious "you" taking action. Sometimes the question comes to the foreground from somewhere else, from some not-so-well lit part of your mind. Those questions that come on their own are usually itches small enough you can live with it indefinitely, but uncomfortable enough so you do not want to.

In the past years, these itches have moved me to learn a little bit about drawing, 3D modeling, programming Android apps and lately into deeper understanding of authorization systems.

The latest itch that I have cared to scratch was the following question: "How much difficult would it be to implement a fine grained, externalized authorization system, for services published in Kubernetes?.

## Why does it matter?
## XXX Call to adventure XXX (XXX remove subtitle)
I have been lately in contact with many companies that willing to be small and big at the same time.

These companies want the benefits of both of these types of companies, without renouncing to the benefits of the other. Oversimplifying this: small companies are disruptive, fast, and leverage the power of an agile mindset; big companies are strong, sound, can embark in big projects and thrive in heavily regulated markets. When companies want it all, some challenges arise and some tradeoffs must be made.

At some point a big company finds that moving its authorization schema to Kubernetes is not an easy task. At the same point, a small company, with a small product finds out that authorization is not as simple as it was before.

Deciding that a user can access a document based on the role of the user is simple. Making the authorization decision based on the role of the user, plus the document clasification, or the department of the owner of the document, or the identity of the boss of either the document owner or the requester, or the time of day, or some information about the device the user is using, or an online evaluation of the user, that is certainly not so simple.

Even a simple authorization model such as "Doctors can only update the information about their patients, or patients whose doctor has signed an specific delegation" can be tricky to implement if we need to be agile on authorization policy updating.

Broadly speaking I would say that Kubernetes is for small companies and EAM (Externalized Authorization Management) is for big companies. Combining both looks like an interesting exercise, interesting for many parties.

## Doing my homework

When I begun reading about this kind of approach, I found out that Kubernetes is already implementing ABAC (Attribute Based Access Control) in its own APIs, and that most enterprise load balancers / proxies / API gateways do already implement some functionality for EAM (Externalized Authorization Management).

Then, I thought that the question was answered: you already have ABAC for Kubernetes administration, and you may go to Gartner's magic quadrants and market scopes to choose your proxy (and integrate it).

It was an straight answer, but it felt like cheating. A double question came to mi mind "Why doesn't Gartner list most widely used ingress servers?" and "Why don't most widely used ingress servers qualify for a Gartner magic quadrant?".

I think the answer is because these two worlds are yet too far apart. Big software vendors are focused on providing feature rich, heavily extensible solutions for big companies, while small companies are looking for something well integrated with Kubernetes, elastic and small.

OK. So, let's implement an externalized, ABAC authorization system using the common components of a Kubernetes implementation.

## Disclaimer
## XXX Refusal of the call XXX (XXX remove subtitle)
What comes next is my experience implementing a "Minimum Viable Prototype"; a system with just the necessary features to answer my questions. There is much work to be done for a high throughput solution. Nevertheless I hope this helps others in the first steps of this road.

## Forming the panoply / Choosing the tools
## XXX Meeting with the mentor XXX (XXX remove subtitle)

Once I decided to make a PoC (Proof of Concept), I wanted to find a stack that was as suitable for the task as it was for me. I needed a simple way to install Kubernetes, a load balancer, an authorization engine, an external source for user information and I would have to create some glue component (preferably in golang) to make it all work together.

For the simple Kubernetes I decided to use minikube (https://kubernetes.io/docs/setup/minikube/) after reading through different options (https://kubernetes.io/docs/setup/pick-right-solution/). It is a compact deployment, well documented, widely used Kubernetes with all the features I need, that fits in one virtual machine.

Regarding the load balancer, I thought I would have to write some module or plug-in to modify the request processing flow, so I decided to go for a golang-based balancer. I found Traefik (https://traefik.io/), and the more I learnt about it, the more I liked it. Traefik is also backed by a company: Containous (https://containo.us/), it is very well integrated into Kubernetes, the code seemed clear to me as well as the contribution documentation, which  explained how to build the project.

I already feel comfortable with XACML (https://es.wikipedia.org/wiki/XACML), so I decided to try something new. I opted for Open Policy Agent (https://openpolicyagent.org), which I found thanks to Prabath Siriwardena's talks (https://es.slideshare.net/prabathsiriwardena/microservices-security-landscape-119821885).

For me, OPA (Open Policy Agent) has a lot of appealing features: it is multi-purpose (not just for access control), it is in use by some big companies such as Netflix, it is already used for Kubernetes APIs ABAC, it already has a company backing it: Styra (https://www.styra.com/), it is very well suited to understand "what is missing" in order to fulfill a policy, it has logs about how the policy was evaluated, and it is written in the Go programming language. All this made it really intriguing.

In addition to OPA features, there are a couple of examples similar to what I was trying to do in this PoC: there is an integration very similar to the one in this PoC with Istio (https://github.com/open-policy-agent/opa-istio-plugin), and there is an explanation on how to authorize API calls with a web server that can echo requests to OPA (https://www.openpolicyagent.org/docs/http-api-authorization.html). The former was too particular for me, and the later required too much coupling between the API server and OPA for my taste, nevertheless they are very close to what I was looking for.

Most common source of user information in the enterprise is the corporate directory. OPA is very aware of this, and has very specific recommendations on how to manage such information, so I decided to use a database. A simple MySQL with a simple schema that would provide user attributes required to evaluate some authorization policies.

All components seemed to have good documentation and an active community in case I required some help.

The stack was chosen, now the work begun.

## Opaefik
## XXX Crossing the first threshold XXX (XXX remove subtitle)

When thinking about something, it is very important to have a name for it. My first approach to "gluing" Traefik (the ingress) and OPA (the policy engine) was developing an authorization adapter plug-in for Traefik, so after discarding "Opafier", "Traeffopa" and "Mantis shrimp", I named this "Opaefik".

## The road of trials
## XXX Tests, allies and enemies / The road of trials XXX (XXX remove subtitle)

Let's take a closer look at the challenges that each component meant.

### Diving into Kubernetes

I think Kubernetes is the best-known component in this stack, so I won't spend much time talking about it.

I would just like to state how good the documentation is. I have needed external documentation understand complex concepts like VxLAN, but Kubernetes documentation is very clear and its structure guides you slowly deeper into the complexities of the system.

### Diving into Traefik

Traefik does not mess around user authentication; it relies on external sources. I like this segregation of duties very much. From a general architectural and security point of view, as well as from a practical point of view for the task at hand.

The integration with Kubernetes is great. So much so, I almost forgot about the internals of service publishing, discovery, balancing, etc. It comes with a very useful dashboard that summarizes the services balanced, the backends, its status and most of the information I ever wanted to know about an ingress.

The source code is easy to understand, contribution process includes information on how to build the project, it does not have yet a plug-in framework (https://github.com/containous/traefik/issues/1336), but it is overall a good base to work. I would possibly have liked to get more trace information in DEBUG log level, but that may be just me.

Only after learning how to compile the source and finding where could I take control of the requests being processed, I learnt about the authentication forwarding functionality, which I finally used.

Authentication forwarding works like this: when a request comes into Traefik, most of it (including URL and user) is forwarded to an external URL; if this external authenticator returns HTTP code 200 OK, the original request is processed. Otherwise, the result of the authentication is sent to the original caller including HTTP code and body.

Authentication is not authorization but this functionality comes handy. It loosens the coupling with the authorization adapter. For a productive scenario I would probably extend Traefik to be able to pass additional information to the "external authenticator".

### Diving into OPA

OPA has a really nice tutorial about how to define policies and evaluate them. It teaches you how to use OPA, but it also helps you have the appropriate mindset to work with OPA.

Understanding Rego (the policy definition language for OPA) has been much more challenging than I anticipated, possibly because its declarative nature feels strange to me. Once you get to feel comfortable with Rego, it is really easy (and short) to define policies. Certainly not a language for business people, but a great fit for technicians.

OPA comes with a few guidelines about how to manage user information, with special mention to "how to get user information from Active Directory". I can't imagine how many times OPA team may have had this conversation with customers and prospects, but I feel sorry for them already.

Even after reading these guidelines I wanted to go against them and extend OPA to make it fetch user information. I'm glad I didn't do it. Following the guides, OPA is an endpoint with no status (except the policies), which makes it trivially scalable.

I was unable to manage and evaluate different policies, so I opted for different functions in just one policy. It is more than enough for the scope of this MVP and leaves room for improvement.

It is possible to call OPA via REST calls, so once again I didn't have to get into the source code.

There are two very interesting features of OPA that I did not use, but have an extraordinary potential:
- Decision logs (https://www.openpolicyagent.org/docs/decision_logs.html): logs "explaining" how a decision was made.
- Partial evaluation (https://blog.openpolicyagent.org/partial-evaluation-162750eaf422): when a policy is evaluated and some components are unknown, these components are returned to the caller. It enables features such as SQL manipulation for policy enforcing (https://blog.openpolicyagent.org/write-policy-in-opa-enforce-policy-in-sql-d9d24db93bf4).

### The component versions

The setup should not be surprising at this point: Ubuntu 18.04.2 LTS, Minikube v0.33.1, Open Policy Agent 0.10.3, Traefik 1.7.8 and Opaefik 1.0 (of course).

## In theory, theory and practice are the same. In practice, they are not
## Approach to the innermost cave / the vision quest (xxx remove subtitle)

Once components were clear. It was time to implement the PoC.

### The resulting architecture

After getting familiar with the components, I decided to go for a simple architecture: XXX add architecture diagram including MySQL XXX. It resembles very much to XACML architecture, doesn't it?

The obvious keystone is Opaefik, and of course it depends on both OPA's and Traefik's interfaces. While implementing it I began noticing more and more dependencies both technical and organizational. I hope I'll spend some time exploring and writing about the complexities of this component.

### The implementation
## The ordeal (xxx remove subtitle)
Detailing the process would be too tedious for this post, so I'll save it for some other time. I'll try to give just enough information for the curious without losing the attention of less technical colleagues

When a request to a protected service is received, this is the process that takes place
- Traefik forwards request information to Opaefik.
- Opaefik decides which is the appropriate policy to be applied (it depends on the service), and what is the set of additional information that must be retrieved (it depends on the policy).
- Opaefik gets the additional information from an external source (a simple MySQL database)
- Opaefik sends all the required information to OPA for it to make a decision.
- OPA evaluates the policy and returns the "verdict"
- Opaefik brings the answer back to Traefik: OK if the request has to be processed, or an error for Traefik to forward to the user. This error contains information to help in the troubleshooting.

The code of Opaefik includes the code required to manage both the communications with Traefik and OPA. It also contains code to analyze the original HTTP request, choose the appropriate policy to evaluate, find the attributes that are required for the specific policy, and finally connect to the MySQL database and get user attributes.

All these parts of the code are just the stub of what they should be in a production-ready implementation, but it is astonishing that all of them fit in 250 lines of Go code.

The authorization policy is very simple. It is just 24 lines long and it enables five different scenarios:
- Public: services that do not require authentication.
- Authenticated: user must be authenticated, no further evaluation is made.
- MAC (Mandatory Access Control): user must be an specific user.
- Group: user must belong to an specific group.
- Organization: user must belong to an specific organization.

## Conclusions
## Reward / The boon (xxx remove subtitle)

Implementing a simple adapter and using a standard Kubernetes setup you may get ABAC authorization in a Kubernetes ingress, apply fine grained authorization to the published services and maintain a separate management of the policies.

Externalized authorization management nowadays is not something you may get out-of-the-box with the widely used Kubernetes toolbox, but it is certainly something you can implement. Depending on the team you have, the organization you belong to, the road-map of the services, etc it is possible to implement a simple, small, performing and easy to maintain piece to orchestrate these authorizations.

## My personal takeaways
## The road back (xxx remove subtitle)

I have learnt a huge deal making the implementation and I have really had a good time. It has been a really interesting and amusing exercise.

I feel this is an unfinished job. There are so many things I wanted to do. I wanted to tighten the coupling between Traefik, Opaefik and OPA in order to reduce execution times. I wanted to cache information to avoid accesses to the database. I wanted to optimize the authorization policies. I wanted to implement a plug-in mechanism to retrieve user information. I wanted to improve Opaefik architecture to decouple the efforts of different teams.

I wanted to continue so many paths, but I had to stop at some point, and I choose this one.

## Resurrection (xxx remove subtitle)

Evaluating the results of the PoC in terms of questions and answers, I must admit I have much more questions than before. Some of these are:
- How could we make a good architecture for Opaefik that takes into account Conway's law?
- How could we optimize OPA policies?
- Would it be easy to manipulate REST requests in the same way as with SQL (https://blog.openpolicyagent.org/write-policy-in-opa-enforce-policy-in-sql-d9d24db93bf4)?
- What implications in terms of team coupling and business logic complexity would it have?

I hope I will have time to think about them all. If I cannot scratch all these itches, I hope I'll have time for at least some of them.

## Final note
## Return with the elixir (xxx remove subtitle)

I write this in the hope of it being helpful for others. I have had enough fun along the way, but maybe someone will want to take the road where I left it and go one step further. If that's the case, I wish you enjoy your journey as much as I have.

Please do not hesitate to give me your feedback. It will be more than welcome.
